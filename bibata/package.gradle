ext {
    themeDescription = [
        shapes : [
            Modern : 'rounded edge',
            Original : 'sharp edge'
        ],
        colors : [
            Amber : 'Yellowish',
            Classic : 'Black',
            Ice : 'White',
            DarkRed : 'Rich red',
            DodgerBlue : 'Slightly light blue',
            Pink : 'Queen pink',
            Turquoise : 'Sky blue with green tint'
        ]
    ]
}

def themeComment(Map args) {
    def comment = "${themeDescription.colors[args.color]} and ${themeDescription.shapes[args.shape]}"
    if (args.leftHand) comment += ', left-handed'
    if (args.outline) comment += ', thin-outline'
    if (args.shadow) comment += ' with pointer shadow'
    //if (args.sizing) comment += " (${ sizing.toLowerCase() })"
    return comment + ' Bibata cursors'
}

def themeName(Map args) {
    def name = "Bibata ${args.shape} ${args.color}"
    if (args.leftHand) name += " Left-Handed"
    if (args.sizing == 'Extra-Large') name += ' [x-large]'
    else if (args.sizing) name += " [${ args.sizing.toLowerCase() }]"
    def tags = [ args.outline ? 'thin' : null,
                 args.shadow ? 'shadow' : null ] - null - ''
    return tags.empty ? name : name + " (${ tags.join(', ') })"
}

task windowsInstallScripts {
    description = 'install.inf, uninstall.cmd'
    group = 'package'

    outputs.dir("${buildDir}/windows-scripts")
    outputs.upToDateWhen { false }

    doLast {
        cartesianProduct(0, themeShapes.split(',') as List,
                            themeColors.split(',') as List,
                            leftHandOpts.split(',') as List).each { row ->
            def args = [ shape: row[0],
                         color: row[1],
                         leftHand: row[2] ]

            def themeIndex = 1
            def setupInfo = [
                name: themeName(args),
                comment: themeComment(args),
                fileSets: [:],
                destinationDirs: [],
                schemesReg: [],
                strings: []
            ]
            windowsSizes.split(',').each { schemeSize ->
                args << [ sizing: schemeSize,
                          outline: null,
                          shadow: null ]

                addSetupInfo(args, themeIndex++, setupInfo)
                if (args.sizing != 'Extra-Large')
                    addSetupInfo(args << [shadow: 'Shadow'], themeIndex++, setupInfo)

                addSetupInfo(args << [outline: 'Thin', shadow: null], themeIndex++, setupInfo)
                if (args.sizing != 'Extra-Large')
                    addSetupInfo(args << [shadow: 'Shadow'], themeIndex++, setupInfo)
            }
            writeWindowsInstallScripts(setupInfo)
        }
    }
}

def writeWindowsInstallScripts(Map setupInfo) {
    def properties = [
        name: setupInfo.name,
        comment: setupInfo.comment,
        version: "v${cursorsVersion}",
        copyFiles: setupInfo.fileSets.keySet().join(','),
        destinationDirs: setupInfo.destinationDirs.join('\n'),
        schemesReg: setupInfo.schemesReg.join('\n'),
        sourceFiles: setupInfo.fileSets.values().join('\n\n'),
        strings: setupInfo.strings.join('\n')
    ]

    copy {
        into "${buildDir}/windows-scripts"
        from('src/package') {
            include 'install.inf'
            //include 'uninstall.cmd'
        }
        rename {
            it.replace('install',
                    "install-${ properties.name.replace(' ', '-') }")
        }
        expand(properties) {
            escapeBackslash = true
        }
    }
}

def addSetupInfo(Map args, index, setupInfo) {
    def name = themeName(args)
    def srcDir = winCurDir(args)
    def curDir = "Cursors\\Bibata\\${srcDir}"
    def fileList = [ 'Pointer.cur',
                     'Help.cur',
                     'Work.ani',
                     'Busy.ani',
                     'Cross.cur',
                     'Text.cur',
                     'Handwriting.cur',
                     'Unavailable.cur',
                     'Vert.cur',
                     'Horz.cur',
                     'Dgn1.cur',
                     'Dgn2.cur',
                     'Move.cur',
                     'Alternate.cur',
                     'Link.cur',
                     'Pin.cur',
                     'Person.cur',
                     'Pan.cur',
                     'Grabbing.cur',
                     'Zoom-in.cur',
                     'Zoom-out.cur',
                     'Alternate_2.cur',
                     'Alternate_3.cur',
                     'Cross_2.cur',
                     'Unavailable_2.cur' ].collect {
        "${srcDir}\\${it}"
    }

    def fileSetName = "Scheme.${index == 1 ? 'Cur' : index}"
    def curDirVar = "CUR_DIR${index == 1 ? '' : index}"
    def schemeNameVar = "SCHEME_NAME${index == 1 ? '' : index}"

    setupInfo.fileSets[fileSetName] = "[${fileSetName}]\n${ fileList.join('\n') }"
    setupInfo.destinationDirs << "${fileSetName} = 10,\"%BIBATA_DIR%\""
    setupInfo.schemesReg << "HKCU,\"Control Panel\\Cursors\\Schemes\",\"%${schemeNameVar}%\",0x00020000,\"%BD%\\%${curDirVar}%\\%pointer%,%BD%\\%${curDirVar}%\\%help%,%BD%\\%${curDirVar}%\\%work%,%BD%\\%${curDirVar}%\\%busy%,%BD%\\%${curDirVar}%\\%cross%,%BD%\\%${curDirVar}%\\%text%,%BD%\\%${curDirVar}%\\%handwriting%,%BD%\\%${curDirVar}%\\%unavailable%,%BD%\\%${curDirVar}%\\%vert%,%BD%\\%${curDirVar}%\\%horz%,%BD%\\%${curDirVar}%\\%dgn1%,%BD%\\%${curDirVar}%\\%dgn2%,%BD%\\%${curDirVar}%\\%move%,%BD%\\%${curDirVar}%\\%alternate%,%BD%\\%${curDirVar}%\\%link%,%BD%\\%${curDirVar}%\\%pin%,%BD%\\%${curDirVar}%\\%person%\""
    setupInfo.strings << "${curDirVar}            = \"${curDir}\"\n" +
                         "${schemeNameVar}        = \"${name}\""
}

def winCurDir(Map args) {
    def tags = [ args.leftHand, args.shape, args.color,
                 args.sizing ? args.sizing : 'Normal',
                 args.outline, args.shadow] - null - ''
    return tags.join('-')
}

task linuxThemeFiles {
    description = 'index.theme, cursor.theme'
    group = 'package'

    outputs.dir("${buildDir}/linux-themes")
    outputs.upToDateWhen { false }

    doLast {
        cartesianProduct(0, themeShapes.split(',') as List,
                            themeColors.split(',') as List,
                            leftHandOpts.split(',') as List).each { row ->
            def args = [ shape: row[0],
                         color: row[1],
                         leftHand: row[2],
                         sizing: null,
                         outline: null,
                         shadow: null ]

            writeLinuxThemeFiles(args)
            writeLinuxThemeFiles(args << [outline: 'Thin'])
            writeLinuxThemeFiles(args << [shadow: 'Shadow'])
            writeLinuxThemeFiles(args << [outline: null])
        }
    }
}

/*
 * https://wiki.archlinux.org/title/Cursor_themes
 * https://wiki.archlinux.org/title/Xcursorgen
 */
def writeLinuxThemeFiles(Map args) {
    def tags = [ args.leftHand, args.shape, args.color,
                 args.outline, args.shadow ] - null - ''
    def properties = [
        name: themeName(args),
        comment: themeComment(args),
        version: cursorsVersion,
        curDir: 'Bibata-' + tags.join('-')
    ]

    copy {
        into "${buildDir}/linux-themes/${properties.curDir}"
        from('src/package') {
            include 'index.theme'
            include 'cursor.theme'
        }
        expand(properties) {
            escapeBackslash = true
        }
    }
}

/*
 * Maybe use Guava Lists.cartesianProduct(lists)
 */
def cartesianProduct(int index, Collection<?>... options) {
    if (index == options.length) {
        return List.of(Arrays.asList(new Object[options.length]));
    }

    def optionValues = options[index];
    if (optionValues.empty) {
        optionValues = Collections.singleton(null);
    }

    def subProduct = cartesianProduct(index + 1, options);
    def combinations =
            new ArrayList<>(optionValues.size() * subProduct.size());
    optionValues.each { value ->
        if (subProduct == null) {
            subProduct = cartesianProduct(index + 1, options);
        }
        subProduct.each { row ->
            row.set(index, value);
            combinations.add(row);
        }
        subProduct = null;
    }
    return combinations;
}
